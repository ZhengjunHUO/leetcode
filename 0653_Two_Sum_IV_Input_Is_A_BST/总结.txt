naive_firstlist.go 先把树转化为排好序的列表再用双指针求解（同0167_Two_Sum_II）
naive_map.go 是深度搜索，也可以使用广度搜索，需要一个一开始只有根节点的列表，每次（层）操作完后添加它的子节点并删除父节点，直到该列表为空
以上所有的算法时间空间复杂度均为O(n)

另外可以从根开始，确定一个节点，遍历树的高度寻找是否有等于(目标-该节点值)的节点，若没有则选择下一个节点，时间复杂度为O(nlogn)，空间复杂度为O(1)
